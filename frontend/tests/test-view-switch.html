<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TriNetra View Switch Test</title>
    <style>
        body {
            background: #1a1a2e;
            color: white;
            font-family: Arial, sans-serif;
            padding: 20px;
        }
        .test-container {
            max-width: 800px;
            margin: 0 auto;
            background: #16213e;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #00ff87;
        }
        .test-button {
            background: #00ff87;
            color: #1a1a2e;
            border: none;
            padding: 10px 20px;
            margin: 10px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        .test-button:hover {
            background: #00d4ff;
        }
        .test-result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
        }
        .success {
            background: rgba(0, 255, 135, 0.2);
            border: 1px solid #00ff87;
        }
        .error {
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid #ff0000;
        }
        #test-svg {
            border: 1px solid #333;
            background: #0a0a0f;
            margin: 20px 0;
        }
        .view-buttons {
            margin: 20px 0;
        }
        .view-button {
            background: #333;
            color: white;
            border: 1px solid #666;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        .view-button.active {
            background: #00ff87;
            color: #1a1a2e;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>üî¨ TriNetra View Switch Test</h1>
        <p>This test verifies that the network-to-timeline view switching bug has been fixed.</p>
        
        <div class="view-buttons">
            <button id="timeline-view" class="view-button active" onclick="testSwitchView('timeline')">Timeline View</button>
            <button id="network-view" class="view-button" onclick="testSwitchView('network')">Network View</button>
        </div>
        
        <svg id="test-svg" width="600" height="400"></svg>
        
        <div id="test-results"></div>
        
        <div>
            <button class="test-button" onclick="runViewSwitchTest()">üß™ Run Complete View Switch Test</button>
            <button class="test-button" onclick="simulateNetworkView()">üï∏Ô∏è Simulate Network View</button>
            <button class="test-button" onclick="simulateTimelineView()">üìà Simulate Timeline View</button>
            <button class="test-button" onclick="clearAllVisualization()">üßπ Clear Visualization</button>
        </div>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // Test implementation to simulate CHRONOS behavior
        class TestChronos {
            constructor() {
                this.svg = d3.select('#test-svg');
                this.g = this.svg.append('g');
                this.simulation = null;
                this.viewMode = 'timeline';
                this.isPlaying = false;
                this.currentFrame = 0;
                this.selectedNode = null;
                this.animationId = null;
                
                // Test data
                this.data = [
                    { id: 'tx1', from_account: 'acc1', to_account: 'acc2', amount: 1000, suspicious_score: 0.8 },
                    { id: 'tx2', from_account: 'acc2', to_account: 'acc3', amount: 500, suspicious_score: 0.3 },
                    { id: 'tx3', from_account: 'acc3', to_account: 'acc1', amount: 750, suspicious_score: 0.9 }
                ];
                
                this.networkNodes = [];
                this.networkLinks = [];
                
                this.addTestResult('‚úÖ TestChronos initialized successfully', 'success');
            }
            
            clearVisualization() {
                console.log('üßπ TEST: Starting clearVisualization()');
                
                // Stop any ongoing animations
                this.isPlaying = false;
                
                // Clear all SVG content when switching views
                if (this.g) {
                    const elementCount = this.g.selectAll('*').size();
                    this.g.selectAll('*').remove();
                    console.log(`üßπ TEST: Removed ${elementCount} SVG elements`);
                }
                
                // Stop and clear any D3 force simulations
                if (this.simulation) {
                    this.simulation.stop();
                    this.simulation = null;
                    console.log('üßπ TEST: Stopped force simulation');
                }
                
                // Reset stored selections and state
                this.selectedNode = null;
                this.currentFrame = 0;
                
                // Clear any animation intervals
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                    console.log('üßπ TEST: Cancelled animation frame');
                }
                
                console.log('üßπ TEST: Cleared visualization completely for view switch');
                this.addTestResult('üßπ Visualization cleared successfully', 'success');
                
                return true; // Return success indicator
            }
            
            switchView(mode) {
                console.log(`üîÑ TEST: Switching to ${mode} view`);
                
                if (this.viewMode === mode) {
                    this.addTestResult(`‚ö†Ô∏è Already in ${mode} view`, 'error');
                    return false;
                }
                
                const previousMode = this.viewMode;
                this.viewMode = mode;
                
                // Update button states
                document.querySelectorAll('.view-button').forEach(btn => btn.classList.remove('active'));
                document.getElementById(`${mode}-view`).classList.add('active');
                
                // Clear the current visualization before switching
                const clearResult = this.clearVisualization();
                
                if (!clearResult) {
                    this.addTestResult('‚ùå Failed to clear visualization', 'error');
                    return false;
                }
                
                // Small delay to ensure clearing is complete
                setTimeout(() => {
                    if (mode === 'timeline') {
                        this.renderTimeline();
                    } else if (mode === 'network') {
                        this.renderNetwork();
                    }
                    
                    this.addTestResult(`‚úÖ Switched from ${previousMode} to ${mode} view`, 'success');
                }, 100);
                
                return true;
            }
            
            renderNetwork() {
                console.log('üï∏Ô∏è TEST: Rendering network view');
                
                // Verify SVG is clear
                const existingElements = this.g.selectAll('*').size();
                if (existingElements > 0) {
                    this.addTestResult(`‚ùå SVG not clear: ${existingElements} elements remain`, 'error');
                    return false;
                }
                
                // Create simple network nodes
                const nodes = [
                    { id: 'acc1', x: 150, y: 150, type: 'account' },
                    { id: 'acc2', x: 300, y: 200, type: 'account' },
                    { id: 'acc3', x: 450, y: 150, type: 'account' }
                ];
                
                const links = [
                    { source: 'acc1', target: 'acc2' },
                    { source: 'acc2', target: 'acc3' },
                    { source: 'acc3', target: 'acc1' }
                ];
                
                // Create force simulation
                this.simulation = d3.forceSimulation(nodes)
                    .force('link', d3.forceLink(links).id(d => d.id).distance(100))
                    .force('charge', d3.forceManyBody().strength(-300))
                    .force('center', d3.forceCenter(300, 200));
                
                // Add links
                const linkSelection = this.g.append('g')
                    .attr('class', 'test-links')
                    .selectAll('line')
                    .data(links)
                    .enter().append('line')
                    .style('stroke', '#00ff87')
                    .style('stroke-width', 2);
                
                // Add nodes
                const nodeSelection = this.g.append('g')
                    .attr('class', 'test-nodes')
                    .selectAll('circle')
                    .data(nodes)
                    .enter().append('circle')
                    .attr('r', 20)
                    .style('fill', '#00d4ff')
                    .style('stroke', 'white')
                    .style('stroke-width', 2);
                
                // Add labels
                const labelSelection = this.g.append('g')
                    .attr('class', 'test-labels')
                    .selectAll('text')
                    .data(nodes)
                    .enter().append('text')
                    .text(d => d.id)
                    .style('fill', 'white')
                    .style('text-anchor', 'middle')
                    .style('font-size', '12px');
                
                // Update positions on simulation tick
                this.simulation.on('tick', () => {
                    linkSelection
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y);
                    
                    nodeSelection
                        .attr('cx', d => d.x)
                        .attr('cy', d => d.y);
                    
                    labelSelection
                        .attr('x', d => d.x)
                        .attr('y', d => d.y + 5);
                });
                
                this.addTestResult('üï∏Ô∏è Network view rendered successfully', 'success');
                return true;
            }
            
            renderTimeline() {
                console.log('üìà TEST: Rendering timeline view');
                
                // Verify SVG is clear
                const existingElements = this.g.selectAll('*').size();
                if (existingElements > 0) {
                    this.addTestResult(`‚ùå SVG not clear: ${existingElements} elements remain`, 'error');
                    return false;
                }
                
                // Create simple timeline
                const timelineData = this.data.map((d, i) => ({
                    ...d,
                    x: 100 + i * 150,
                    y: 200
                }));
                
                // Add timeline axis
                this.g.append('line')
                    .attr('class', 'timeline-axis')
                    .attr('x1', 50)
                    .attr('y1', 200)
                    .attr('x2', 550)
                    .attr('y2', 200)
                    .style('stroke', '#666')
                    .style('stroke-width', 2);
                
                // Add transaction nodes
                const nodes = this.g.append('g')
                    .attr('class', 'timeline-nodes')
                    .selectAll('circle')
                    .data(timelineData)
                    .enter().append('circle')
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y)
                    .attr('r', 15)
                    .style('fill', d => d.suspicious_score > 0.5 ? '#ff4444' : '#00ff87')
                    .style('stroke', 'white')
                    .style('stroke-width', 2);
                
                // Add labels
                const labels = this.g.append('g')
                    .attr('class', 'timeline-labels')
                    .selectAll('text')
                    .data(timelineData)
                    .enter().append('text')
                    .attr('x', d => d.x)
                    .attr('y', d => d.y - 25)
                    .text(d => d.id)
                    .style('fill', 'white')
                    .style('text-anchor', 'middle')
                    .style('font-size', '12px');
                
                this.addTestResult('üìà Timeline view rendered successfully', 'success');
                return true;
            }
            
            addTestResult(message, type) {
                const resultsDiv = document.getElementById('test-results');
                const resultDiv = document.createElement('div');
                resultDiv.className = `test-result ${type}`;
                resultDiv.innerHTML = `[${new Date().toLocaleTimeString()}] ${message}`;
                resultsDiv.appendChild(resultDiv);
                
                // Keep only last 10 results
                const results = resultsDiv.children;
                if (results.length > 10) {
                    resultsDiv.removeChild(results[0]);
                }
                
                // Scroll to bottom
                resultsDiv.scrollTop = resultsDiv.scrollHeight;
            }
        }
        
        // Global test instance
        let testChronos = new TestChronos();
        
        // Test functions
        function testSwitchView(mode) {
            testChronos.switchView(mode);
        }
        
        function simulateNetworkView() {
            testChronos.renderNetwork();
        }
        
        function simulateTimelineView() {
            testChronos.renderTimeline();
        }
        
        function clearAllVisualization() {
            testChronos.clearVisualization();
        }
        
        function runViewSwitchTest() {
            testChronos.addTestResult('üß™ Starting comprehensive view switch test...', 'success');
            
            // Test sequence
            setTimeout(() => testChronos.switchView('network'), 500);
            setTimeout(() => testChronos.switchView('timeline'), 1500);
            setTimeout(() => testChronos.switchView('network'), 2500);
            setTimeout(() => testChronos.switchView('timeline'), 3500);
            setTimeout(() => {
                testChronos.addTestResult('üéâ View switch test completed successfully!', 'success');
            }, 4500);
        }
        
        // Initialize with timeline view
        testChronos.renderTimeline();
    </script>
</body>
</html>